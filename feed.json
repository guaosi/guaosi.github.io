{"title":"guaosi的博客","description":"guaosi,guaosi的博客,后端,PHP,Linux,golang,python,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,docker","language":"","link":"https://www.guaosi.com","pubDate":"Mon, 03 Feb 2020 10:21:34 GMT","lastBuildDate":"Mon, 03 Feb 2020 10:29:59 GMT","generator":"hexo-generator-json-feed","webMaster":"guaosi","items":[{"title":"Redis初识","link":"https://www.guaosi.com/2020/02/03/understanding-and-use-of-redis-api/","description":"通用命令keyskeys * #遍历所有的key 123456789101112127.0.0.1:6379 &gt; set hello worldOK127.0.0.1:6379 &gt; set php goodOK127.0.0.1:6379 &gt; set java bestOK127.0.0.1:6379 &gt; keys *1) \"java\"2) \"php\"3) \"hello\"127.0.0.1:6379 &gt; dbsize(integer)3 keys [pattern] #遍历所有的key，指定模式(通配符)进行筛选 1234567891011127.0.0.1:6379 &gt; mset hello world hehe haha php good phe hisOK127.0.0.1:6379 &gt; keys he*1)\"hehe\"2)\"hello\"127.0.0.1:6379 &gt; keys he[h-l]*1)\"hehe\"2)\"hello\"127.0.0.1:6379 &gt; keys ph?1)\"php\"2)\"phe\" keys 命令一般不在生产环境中使用，因为生产环境数据庞大，而redis又是单线程机制，keys命令是o(n)复杂度，执行会很慢，且容易阻塞其他命令。keys *怎么用：热备从节点(在从节点上使用)、scan(使用scan命令) dbsizedbsize #计算key的总数该命令可以随便使用，因为redis内置了计数器，会实时更新keys总数，而不需要遍历所有数据。 12345678127.0.0.1:6379 &gt; mset k1 v1 k2 v2 k3 v3 k4 v4OK127.0.0.1:6379 &gt; dbsize(integer)4127.0.0.1:6379 &gt; sadd myset a b c d e(integer)5127.0.0.1:6379 &gt; dbsize(integer)5 existsexists key #检查key是否存在返回值：存在返回1，不存在返回0 12345678127.0.0.1:6379 &gt; set a bOK127.0.0.1:6379 &gt; exists a(integer)1127.0.0.1:6379 &gt; del a(integer)1127.0.0.1:6379 &gt; exists a(integer)0 deldel key [key...] #删除指定key-value，可删除多个返回值：删除成功返回1，key不存在返回0 12345678127.0.0.1:6379 &gt; set a bOK127.0.0.1:6379 &gt; get a\"b\"127.0.0.1:6379 &gt; del a(integer)1127.0.0.1:6379 &gt; get a(nil) expire、ttl、persistexpire key seconds #key在seconds秒后过期 ttl key #查看key剩余的过期时间，-1代表没有过期时间，-2代表key不存在 persist key #去掉key的过期时间 1234567891011121314151617181920212223242526272829# 示例1127.0.0.1:6379 &gt; set hello worldOK127.0.0.1:6379 &gt; expire hello 20(integer)1127.0.0.1:6379 &gt; ttl hello(integer)16127.0.0.1:6379 &gt; get hello\"world\"127.0.0.1:6379 &gt; ttl hello(integer)7127.0.0.1:6379 &gt; ttl hello(integer)-2(-2表示key已经不存在了)127.0.0.1:6379 &gt; get hello(nil)# 示例2127.0.0.1:6379 &gt; set hello worldOK127.0.0.1:6379 &gt; expire hello 20(integer)1127.0.0.1:6379 &gt; ttl hello(integer)16(还有16秒过期)127.0.0.1:6379 &gt; persist hello(integer)1127.0.0.1:6379 &gt; ttl hello(integer)-1(-1代表key存在并且没有过期时间。)127.0.0.1:6379 &gt; get hello\"world\" typetype key #返回key的类型返回值：string、hash、list、set、zset、none(key不存在) 12345678127.0.0.1:6379 &gt; set a bOK127.0.0.1:6379 &gt; type astring127.0.0.1:6379 &gt; sadd myset 1 2 3(integer)3127.0.0.1:6379 &gt; type mysetset 时间复杂度了解命令的时间复杂度对我们使用Redis的API是非常有帮助的，因为我们需要在合理的场景以及合理的数据规模下进行使用。 命令 时间复杂度 keys O(n) dbsize O(1) del O(1) exists O(1) expire O(1) type O(1) 内部编码与单线程数据结构与内部编码Redis对外主要提供了5种数据结构，分别是string、hash、list、set、sorted set 并且对于每一种数据结构redis都提供了至少2种相应的内部编码实现以应对不同的使用场景。 这么做的目的 对于用户的数据存储选择合适的处理策略以达到内存最优使用的目的，即采用以空间换取时间还是以时间换取空间策略 采用面向接口编程思想以达到很好的扩展性，比如对于list类型又完成了一种针对特定场景使用的内部编码实现，那么只需要将内部编码集成到list类型之中，而用户无需关心实际内部编码的使用情况，仍然使用list类型即可 redisObject在Redis源码内部有一个redisObject这样的对象或者说结构体，redis使用redisObject表示所有的key-value。 它里面有很多属性，比较重要的就是数据类型type和编码方式encoding，如图所示。 单线程redis在一个瞬间只会执行一条命令，所有命令以串行方式进行排列，等待顺序执行。如图所示当第一个get命令执行完成之后才会执行第二个get命令，其实这就是redis单线程最简单的一个表现。理解redis单线程非常重要，同时这也是redis设计的精髓所在。 单线程为什么这么快？纯内存redis会将所有数据放在内存中，而内存的响应速度是非常快的。所以redis之所以能达到如此高性能是依赖于内存的。 其实无论你做了很多优化或者说代码的优化实际它的本质是数据放在内存当中。 非阻塞IOredis使用了epoll模型作为IO多路复用的实现，redis自身也实现了事件处理，将epoll的连接、读写、关闭转换为自身的事件，不在网络IO上浪费过多的时间。 避免线程切换和竞态消耗这其实也是单线程的特性，很多时候如果多线程没有达到一个合理的使用时，它甚至比单线程还要慢。 单线程注意事项 一次只运行一条命令 拒绝长(慢)命令(keys, flushall, flushdb, slow lua script, mutil/exec, operatebig value(collection)) 其实不是真正的单线程，在执行fysnc file descriptor和close file descriptor操作时也会单独开一个线程，了解即可 字符串字符串键值结构key：对于redis而言所有的key都是一个字符串 value：实际可以为字符串、数字、二进制、json串 字符串的value最大限制为512MB，其实已经足够大了，实际使用最好不要过大，建议在100k以内。 字符串使用场景 缓存 分布式锁 计数器 还有很多很多应用场景，只要你掌握了这样的API就可以结合你的应用场景进行思考，然后进行API的选用来实现你的功能。 字符串常用命令1234567get key # 获取key对应的value set key value # 设置key-valuedel key # 删除key-valueincr key # key自增1，如果key不存在，自增后get(key)=1decr key # key自减1，如果key不存在，自减后get(key)=-1incrby key k # key自增k，如果key不存在，自增后get(key)=kdecrby key k # key自减k，如果key不存在，自减后get(key)=-k get、set、del命令演示12345678127.0.0.1:6379 &gt; set hello \"world\"OK127.0.0.1:6379 &gt; get hello\"world\"127.0.0.1:6379 &gt; del hello(integer)1127.0.0.1:6379 &gt; get hello(nil) incr、decr、incrby、decrby命令演示123456789101112127.0.0.1:6379 &gt; get counter(nil)127.0.0.1:6379 &gt; incr counter(integer)1127.0.0.1:6379 &gt; get counter\"1\"127.0.0.1:6379 &gt; incrby counter 99(integer)100127.0.0.1:6379 &gt; decr counter(integer)99127.0.0.1:6379 &gt; get counter\"99\" 简单实战记录网站每个用户个人主页的访问量incr userid:pageview (单线程 : 无竞争) redis是天然适合做计数器的，因为是单线程的，所以并发执行incr的时候不会有竞争问题，无论并发量多大都不会记错数。 很多网站或者应用会使用incr或者decr这样的命令来做计数器，非常简单但是非常实用。 分布式id生成器incr id (原子操作) 分布式id生成器，即多个应用并发访问获取的id是自增且不重复的，仍然可以使用incr这样的命令来实现，当然实际的实现方案会比这个要复杂一些，但是最基础的一个实现的思路或者原理都是使用这样一个规则。 其他命令setnx、setxx、setex1234set key value # 不管key是否存在，都进行设置setnx key value # key不存在，才设置，成功返回1set key value xx # key存在，才设置，成功返回OKsetex key seconds value # 设置key-value,同时设置key的过期时间 其实这些都是set命令及选项的组合，使用这种组合命令好处是将多个操作作为一个原子操作来执行，就不会存在并发竞争的问题，在实现一些场景比如分布式锁是非常有用的。 12345678910111213141516171819202122127.0.0.1:6379 &gt; exists php(integer)0127.0.0.1:6379 &gt; set php goodOK127.0.0.1:6379 &gt; setnx php bad(integer)0127.0.0.1:6379 &gt; set php best xxOK127.0.0.1:6379 &gt; get php\"best\"127.0.0.1:6379 &gt; exists java(integer)0127.0.0.1:6379 &gt; setnx java best(integer)1127.0.0.1:6379 &gt; set java easy xxOK127.0.0.1:6379 &gt; get java\"easy\"127.0.0.1:6379 &gt; exists lua(integer)0127.0.0.1:6379 &gt; set lua hehe xx(nil) mget、mset12mget key1 key2 key3... # 批量获取key，原子操作mset key1 value1 key2 value2 key3 value3... # 批量设置key-value 两个命令的时间复杂度都是O(n) mget和mset是批量操作，时间复杂度都是o(n)，是非常方便且能提高性能的命令，但是一定要节制去使用。 使用时需要注意的是对于大数据量的获取，最好将其拆分成多个mget操作，例如获取10万个key操作，每次获取1000个，执行100次mget操作。 123456127.0.0.1:6379 &gt; mset hello world java best php goodOK127.0.0.1:6379 &gt; mget hello java php1)\"world\"2)\"best\"3)\"good\" n次get命令 = n次网络时间 + n次命令时间 1次mget操作 = 1次网络时间 + n次命令时间 这里需要注意的是网络时间，因为客户端和服务端通常是在不同机器甚至是不同的机房、不同的地区，所以网络时间通常是一个很大的开销，而命令本身开销是非常小的，redis大部分命令执行速度都非常快，那么网络时间就显得非常珍贵。所以使用mget这样的操作可以省去大量的网络时间。在很多场景下它的效率是非常高的，当然如果网络时间越长、获取key的个数越多效果越明显。 查缺补漏123456getset key newvalue # set key newvalue并且返回旧的value值append key value # 将value追加到旧的valuestrlen key # 返回字符串长度(注意中文，一个汉字长度为2)incrbyfloat key 3.5 #增加key对应的值加上3.5getrange key start end # 获取字符串指定下标所有的值setrange key index end # 获取指定下标所对应的值 getset、append、strlen其中strlen命令的时间复杂度也是o(1)，redis字符串内部也会对字符串长度进行实时更新，不需要遍历字符串来计算完整的长度。 1234567891011121314127.0.0.1:6379 &gt; set hello worldOK127.0.0.1:6379 &gt; getset hello php\"world\"127.0.0.1:6379 &gt; append hello \",java\"(integer)8127.0.0.1:6379 &gt; get hello\"php,java\"127.0.0.1:6379 &gt; strlen hello(integer)8127.0.0.1:6379 &gt; set hello \"足球\"OK127.0.0.1:6379 &gt; strlen hello(integer)4 incrbyfloat、getrange、setrange1234567891011121314127.0.0.1:6379 &gt; incr counter(integer)1127.0.0.1:6379 &gt; incrbyfloat counter 1.1(integer)2.1127.0.0.1:6379 &gt; get counter(integer)2.1127.0.0.1:6379 &gt; set hello javabestOK127.0.0.1:6379 &gt; getrange hello 0 2\"jav\"127.0.0.1:6379 &gt; setrange hello 4 p(integer)8127.0.0.1:6379 &gt; get hello\"javapest\" 常用命令总结 命令 含义 复杂度 set key value 设置key-value O(1) get key 获取key-value O(1) del key 删除key-value O(1) setnx setxx 根据key是否存在设置key-value O(1) incr decr 计数 O(1) mget mset 批量操作key-value O(n) 哈希哈希键值结构key仍然是一个字符串，value其实分为两个部分，field代表某个属性，value代表属性的值。在哈希结构中，可以添加一个新的属性和值，也可以修改或者删除某个属性，这与字符串有很大的不同。如果用字符串实现新增属性的话需要将整个value取出来做一个反序列化，然后添加属性后重新序列化存入Redis中。 特点实际上哈希是一个Mapmap的结构，也就是外层是一个key-value结构，对于value内部而言又是一个map结构。 对于内部的map结构而言，field不能相同，而value可以相同。 哈希相关API常用命令12345hget key field # 获取hash key对应field的valuehset key field value # 设置hash key对应field的valuehdel key field # 删除hash key对应field的valuehexists key field # 判断hash key是否有fieldhlen key # 获取hash key field的数量 常用命令演示1234567891011121314151617181920127.0.0.1:6379 &gt; hset user:1:info age 23(integer)1127.0.0.1:6379 &gt; hget user:1:info age 23\"23\"127.0.0.1:6379 &gt; hset user:1:info name ronaldo(integer)1127.0.0.1:6379 &gt; hgetall user:1:info1)\"age\"2)\"23\"3)\"name\"4)\"ronaldo\"127.0.0.1:6379 &gt; hexists user:1:info name(integer)1127.0.0.1:6379 &gt; hlen user:1:info(integer)2127.0.0.1:6379 &gt; hdel user:1:info age(integer)1127.0.0.1:6379 &gt; hgetall user:1:info1)\"name\"2)\"ronaldo\" hmget、hmset123hmget key field1 field2... fieldN # 批量获取hash key的一批field对应的值hmset key field1 value1 field2 value2... fieldN valueN # 批量设置hash key的一批field value# 两个命令的时间复杂度都是O(n) hmget、hmset命令演示1234567127.0.0.1:6379 &gt; hmset user:2:info age 30 name kaka page 50OK127.0.0.1:6379 &gt; hlen user:2:info(integer)3127.0.0.1:6379 &gt; hmget user:2:info age name1)\"30\"2)\"kaka\" hgetall、hvals、hkeys小心使用 hgetall 命令，它会返回所有的field和value，如果你的hash key存入了很多属性比如一万条，使用该命令执行速度就会非常慢，牢记redis是单线程的。大多数情况下应该都不需要把所有的属性都取出来。 1234hgetall key # 返回hash key对应所有的field和valuehkeys key # 返回hash key对应所有fieldhvals key # 返回hash key对应所有field的value# 三个时间复杂度都是O(n) hgetall、hvals、hkeys命令演示123456789101112131415127.0.0.1:6379 &gt; hgetall user:2:info1)\"age\"2)\"30\"3)\"name\"4)\"kaka\"5)\"page\"6)\"50\"127.0.0.1:6379 &gt; hvals user:2:info1)\"30\"2)\"kaka\"3)\"50\"127.0.0.1:6379 &gt; hkeys user:2:info1)\"age\"2)\"name\"3)\"page\" hsetnx、hincrby、hincrbyfloat123hsetnx key field value # 设置hash key对应field的value(如field已经存在，则失败)hincyby key field intCounter # hash key对应的field的value自增intCounterhincybyfloat key field floatCounter # hincyby浮点数版 简单实战记录网站每个用户个人主页的访问量hincrby user:1:info pageview count定义一个含有用户ID的key，然后在value中我们增加了pageview属性，用它来记录该用户的访问量。这种方式与字符串不同的是，字符串一个key只能存储访问量，如果还需要存储用户的其他属性，需要再单独定义相应的key，而使用哈希则可以存储用户的完整信息。 如何更新用户属性方案一将用户的ID作为key，然后它的value是将所有的属性作为一个整体序列化的结果，比如是一个json串。如果需要获取就将value取出进行反序列化成相应的对象，如果需要重新写入，就将修改后的对象重新序列化写回给redis 方案二用户ID和每个属性作为一个key，属性值作为value进行存储。这样更新某个属性值就非常方便，而且添加新的属性也不会影响原有的key，缺点是用户的信息不是一个整体，不便于管理。 方案三就是我们介绍的使用hash的方式，将所有的属性和值作为hash的value进行存储，可以单独更新或者删除某个属性，并且也可以很方便的添加新的属性。 三种方案对比 命令 优点 缺点 string v1 编程简单 可能节约内存 1. 序列化开销大 2.设置属性要操作整个数据 string v2 直观 可以部分更新 1. 内存占用较大 2. Key较为分散 hash 直观 节约空间 可以部分更新 1. 编程稍微控制 2. ttl不好控制 哈希总结 命令 复杂度 hget hset hdel O(1) hexists O(1) hincyby O(1) hgetall hvals hkeys O(n) hmget hmset O(n) 列表列表结构key仍然是一个字符串，value是一个有序队列，且可以重复，左右两边插入弹出。 可以计算列表的长度-llen，删除列表中指定的某个元素-lrem，获取子列表-lrange，按照索引获取列表值-lindex 列表重要API增相关123rpush key value1 value2 ...valueN # 从列表右边插入值(1-N个)，O(1~N)lpush key value1 value2 ...valueN # 从列表左边插入值(1-N个)，O(1~N)linsert key before|after value newValue # 在list指定的值前|后插入newValue,O(n) 命令演示效果如图 删相关1234567lpop key # 从列表左侧弹出一个itemrpop key # 从列表右侧弹出一个itemltrim key start end # 按照索引|范围修减列表,O(n)lrem key count value # 根据count值，从列表中删除所有value相等的项，O(n)(1)count&gt;0，从左到右，删除最多count个value相等的项(2)count&lt;0，从右到左，删除最多Math.abs(count)个value相等的项(3)count=0，删除所有value相等的项 lpop、rpop、lrem命令演示效果 ltrim命令演示效果ltrim命令在做一些大的列表删除时是非常有用的，假设数据量是上百万，如果直接执行del key会将redis阻塞掉，我们可以使用ltrim每次裁剪10万分之一数据，最后达到一个删除的效果。 查相关123lrange key start end(包含end) # 获取列表指定索引范围所有item，O(n)lindex key index # 获取列表指定索引的item，O(n)llen key # 获取列表长度，O(1) 命令演示效果如图 改相关1lset key index newValue # 设置列表指定索引|值为newValue，O(n) 命令演示12345678910111213141516171819127.0.0.1:6379 &gt; rpush mylist a b c(integer)3127.0.0.1:6379 &gt; lrange mylist 0 -11)\"a\"2)\"b\"3)\"c\"127.0.0.1:6379 &gt; lpush mylist 0(integer)4127.0.0.1:6379 &gt; lrange mylist 0 -11)\"0\"2)\"a\"3)\"b\"4)\"c\"127.0.0.1:6379 &gt; rpop mylist\"c\"127.0.0.1:6379 &gt; lrange mylist 0 -11)\"0\"2)\"a\"3)\"b\" 实战-TimeLine实际上就是微博的时间轴功能，会将你关注的用户最新的微博按照从新到旧的顺序来排列，这和我们的列表是非常类似的，可以使用类似lpush、rpush、lpop、rpop这样的功能，还可以按照每10页做一个分页。比如微博列表顺序，就是以关注用户的微博ID作为key，而用户的如微博内容、点赞数等等信息则可以另外存储到一个比如哈希结构里，通过微博ID就可以进行一个关联。假设你关注的人更新了微博，就可以使用lpush命令去更新list数据，使用lrange命令获取最新的10条微博，然后通过hmget命令去哈希中取出微博的具体内容。 查缺补漏执行这两个命令会有一个阻塞的过程，如果设置了非0的timeout，那么当列表为空时，命令不会立即返回结果，而是阻塞等待直到超时，或者当有新的值被插入时就会进行获取并返回。在实现类似消息队列功能时会非常有帮助。 1234blpop key timeout# lpop阻塞版本，timeout是阻塞超时时间，timeout=0表示阻塞时间是无限的brpop key timeout# rpop阻塞版本，timeout是阻塞超时时间，timeout=0表示阻塞时间是无限的 小的TIPS LRUSH + LPOP = Stack(栈) LPUSH + RPOP = Queue(队列) LPUSH + LTRIM = Capped Collection(固定数量的列表) LPUSH + BRPOP = Message Queue(消息队列) 集合集合结构key仍然是一个字符串，value就是一个集合，它可以将若干个字符串进行一个组合。集合的特点是无序，无重复元素，同时支持集合间操作，比如求并集、交集和差集。 集合内API添加和删除12sadd key element... O(1~n) # 向集合key添加一个或多个element(如果element已经存在，添加失败)srem key element... O(1~n) # 将集合key中的一个或多个element移除掉 其他命令注意smembers命令，它返回的结果是无序的，由于它会返回集合中所有的元素，需要小心使用。如果集合内元素过多，可以使用sscan命令进行扫描。 12345scard user:1:follow = 4 # 计算集合大小sismember user:1:follow it = 1(存在) #判断it是否在集合中srandmember user:1:follow count = his #从集合中随机挑count个元素spop user:1:follow = sports # 从集合中随机弹出一个元素smembers user:1:follow = music his sports it # 获取集合所有元素 命令演示1234567891011121314151617127.0.0.1:6379 &gt; sadd uesr:1:follow it news his sports(integer)4127.0.0.1:6379 &gt; smembers user:1:follow1)\"news\"2)\"his\"3)\"it\"4)\"sports\"127.0.0.1:6379 &gt; spop user:1:follow\"news\"127.0.0.1:6379 &gt; smembers user:1:follow1)\"his\"2)\"it\"3)\"sports\"127.0.0.1:6379 &gt; scard uesr:1:follow(integer)3127.0.0.1:6379 &gt; sismember uesr:1:follow entertainment(integer)0 简单实战抽奖系统可以将所有满足条件的用户存入到集合中，只需要存入一个用户唯一标识即可。然后使用spop命令或者srandmember进行随机元素弹出，弹出的用户就作为中奖用户。当活动结束后将集合进行删除。 Like、赞、踩如果用户进行了Like、赞、踩，我们就可以将该用户放入到这个微博或者新闻的赞、踩集合当中。需要展示赞、踩的用户列表时就可以进行取出，当然这个也可以使用其他数据类型来实现。 标签(tag)我们可以给用户添加标签，也可以给标签添加用户，看看关心这个标签的都有哪 些用户。实际上这两个操作应该是同事务下的，可以使用事务来结合使用，关于事务后续章节会介绍。 集合间API其实就是计算集合间的差集(sdiff)、交集(sinter)和并集(sunion)，也可以把计算结果保存在指定key中。 1234sdiff user:1:follow user:2:follow = music his # 差集sinter user:1:follow user:2:follow = it sports # 交集sunios user:1:follow user:2:follow = it sports music his news ent# 并集sdiff|sinter|sunion + store destkey ...#将差集、交集、 并集结果保存在destkey中 集合间实战这个在微博或者其他一些社交网站是用的比较多的，比如展示用户间共同关注的好友，共同关注的兴趣等等都可以使用集合间API来进行实现。 小的TIPS SADD = Tagging SPOP/SRANDMEMBER = Random item SADD + SINTER = Social Graph 有序集合有序集合结构key仍然是一个字符串，value就是一个集合，在有序集合中一个元素又包含了score和value，score用于排序可重复，而value不可以重复。 集合 vs 有序集合有序集合每个元素都带有分数，分数可以重复，以分数作为排序规则，有序集合中的成员在集合中的位置是有序的有序集合可以实现很多集合实现不了的功能，同时它的API相对于集合来说时间复杂度是普遍偏高的，因为它需要体现一个有序的概念，所以并不是说集合就毫无用处了。 集合 有序集合 无重复元素 无重复元素 无序 有序 element element+score 列表 vs 有序集合 集合 有序集合 可以有重复元素 无重复元素 有序 有序 element element+score 有序集合重要API基础命令1234567zadd key score element(可以是多对) #添加score和element，O(M*log(N))(如果元素存在，则改变它的分数)zrem key element(可以是多个) # 删除元素，O(M*log(N))zscore key element # 返回元素的分数，O(1)zrank key element # 获取元素的排名(从0开始)，O(log(N))zincrby key increScore element # 增加或减少元素的分数，O(log(N))zcard key # 返回元素的总个数,O(1)# M作为操作元素的个数，N是指集合元素的个数 基础命令演示1234567891011121314151617127.0.0.1:6379 &gt; zadd player:rank 1000 ronaldo 900 messi 800 c-ronaldo 600 kaka(integer)4127.0.0.1:6379 &gt; zscore play:rank kaka\"600\"127.0.0.1:6379 &gt; zcard play:rank(integer)4127.0.0.1:6379 &gt; zrank play:rank ronaldo(integer)3127.0.0.1:6379 &gt; zrem play:rank messi ronaldo(integer)1127.0.0.1:6379 &gt; zincrby play:rank 100 kaka(integer)1127.0.0.1:6379 &gt; zrange play:rank 0 -1 withscores1)\"kaka\"2)\"700\"3)\"c-ronaldo\"4)\"800\" 高级命令12345zrange key start end [withscores] # 返回指定索引范围内的升序元素[分值]，O(log(N)+M)zrangebyscore key minScore maxScore [withscores] # 返回指定分数范围内的升序元素[分值],O(log(N)+M)zcount key minScore maxScore # 返回有序集合内在指定分数范围(闭区间)内的个数，O(log(N))zremrangebyrank key start end # 删除指定排名内的升序元素，O(log(N)+M)zremrangebyscorek key minScore maxScore # 删除指定分数内的升序元素，O(log(N)+M) 高级命令演示12345678910111213141516171819202122127.0.0.1:6379 &gt; zadd player:rank 1000 ronaldo 900 messi 800 ronaldo 600 kaka(integer)4127.0.0.1:6379 &gt; zrange play:rank 0 -11)\"kaka\"2)\"c-ronaldo\"3)\"messi\"4)\"ronaldo\"127.0.0.1:6379 &gt; zcount player:rank 700 901(integer)2127.0.0.1:6379 &gt; zrangebyscore play:rank 700 9011)\"c-ronaldo\"2)\"messi\"127.0.0.1:6379 &gt; zremrangebyrank player:rank 0 1(integer)2127.0.0.1:6379 &gt; zrange play:rank 0 -11)\"messi\"2)\"ronaldo\"127.0.0.1:6379 &gt; zrange play:rank 0 -1 withscores1)\"messi\"2)\"900\"3)\"ronaldo\"4)\"1000\" 实战-排行榜排行榜功能在很多应用都是普遍存在的，例如音乐排行榜、电影排行榜、文章排行榜、热门视频等等。类似这种场景就可以使用有序集合来实现。可以使用zadd去添加元素和初始分数，然后使用zincrby实现分数的更新，使用zrem将一些元素删除榜外，使用zrangebyscore获取一定范围分数的榜单等等。那么这里最核心的就是分数具体代表什么，例如最新榜单可以使用timeStamp作为分数，销售量可以使用saleCount，关注量使用followCount。然后使用相关的API进行业务操作，也可以对多个集合进行汇总根据一定的规则作为类似综合排序的结果。 查缺补漏对于一些不太常用的命令或者不太典型的命令进行查缺补漏。 12345zrevrank key element # 获取元素的排名(元素是按从大到小排列),O(log(N))zrevrange key start end [withscores] # 返回指定索引范围内的降序元素[分值],O(log(N)+M)zrevrangebyscore key minScore maxScore [withscores] # 返回指定分数范围内的降序元素[分值],O(log(N)+M)zinterstore # 求多个有序集的交集，并存储到指定keyzunionstore # 求多个有序集的并集，并存储到指定key 有序集合总结 操作类型 命令 基本操作 zadd zrem zcard zincrby zscore 范围操作 zrange zrangebyscore zcount zremrangebyrank 集合操作 zunionstore zinterstore go-redis的使用golang中比较好用的第三方开源redisclient有: go-redis 源码地址：https://github.com/go-redis/redis 文档地址：http://godoc.org/github.com/go-redis/redis redigo 源码地址：https://github.com/gomodule/redigo 文档地址：http://godoc.org/github.com/gomodule/redigo/redis 两个都是非常优秀的redisclient库，也是redis官网上推荐，我选择是的是go-redis，因为go-redis封装了redis的大部分命令，不用关心redis的命令的细节，直接调用相应接口就行；redigo是基于命令的，发送一个命令，然后在解析reply；所以相对而言，我觉得go-redis接口更友好。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364package mainimport ( \"fmt\" \"github.com/go-redis/redis\")func main() &#123; client := redis.NewClient(&amp;redis.Options&#123; Addr: \"localhost:6379\", Password: \"\", // no password set DB: 0, // use default DB PoolSize: 10, // 资源池设置链接数大小 MinIdleConns: 3, //闲置时资源池链接数大小 &#125;) pong, err := client.Ping().Result() fmt.Println(pong, err) // Output: PONG &lt;nil&gt; // 1.string //输出结果: world client.Set(\"hello\",\"world\",0) if result,err:=client.Get(\"hello\").Result();err==nil&#123; fmt.Println(result) &#125; //输出结果:1 if result,err:=client.Incr(\"counter\").Result();err==nil&#123; fmt.Println(result) &#125; // 2.hash client.HSet(\"myhash\", \"f1\", \"v1\") client.HSet(\"myhash\", \"f2\", \"v2\") //输出结果 : map[f1:v1 f2:v2] if result,err:=client.HGetAll(\"myhash\").Result();err==nil&#123; fmt.Println(result) &#125; // 3.list client.RPush(\"mylist\", \"1\") client.RPush(\"mylist\", \"2\") client.RPush(\"mylist\", \"3\") //输出结果 : [1, 2, 3] if result,err:=client.LRange(\"mylist\", 0, -1).Result();err==nil&#123; fmt.Println(result) &#125; // 4.set client.SAdd(\"myset\", \"a\"); client.SAdd(\"myset\", \"b\"); client.SAdd(\"myset\", \"a\"); //输出结果 : [b, a] if result,err:=client.SMembers(\"myset\").Result();err==nil&#123; fmt.Println(result) &#125; // 5.zset client.ZAdd(\"myzset\", redis.Z&#123;99,\"tom\"&#125;) client.ZAdd(\"myzset\", redis.Z&#123;66,\"peter\"&#125;) client.ZAdd(\"myzset\", redis.Z&#123;33,\"james\"&#125;) //输出结果 : [&#123;33,\"james\"&#125; &#123;66,\"peter\"&#125; &#123;99,\"tom\"&#125;] if result,err:=client.ZRangeWithScores(\"myzset\", 0, -1).Result();err==nil&#123; fmt.Println(result) &#125;&#125;","pubDate":"Mon, 03 Feb 2020 10:21:34 GMT","guid":"https://www.guaosi.com/2020/02/03/understanding-and-use-of-redis-api/","category":"Redis"},{"title":"Redis初识","link":"https://www.guaosi.com/2020/02/03/first-acquaintance-with-redis/","description":"简介Redis是什么 Redis - REmote DIctionary Server Redis是一个使用ANSI C语言编写的开源数据库 高性能的key-value数据库 内存数据库，支持数据持久化 提供了多种编程语言的客户端 从2010年3月15日起，Redis的开发工作由VMware主持 从2013年5月开始，Redis的开发由Pivotal赞助 官网：https://redis.io/中文官网：http://www.redis.cn/","pubDate":"Mon, 03 Feb 2020 10:20:47 GMT","guid":"https://www.guaosi.com/2020/02/03/first-acquaintance-with-redis/","category":"Redis"},{"title":"深入RabbitMQ高级特性(Golang演示)","link":"https://www.guaosi.com/2020/01/29/dive-into-the-advanced-features-of-rabbitmq-with-golang/","description":"保障消息 100% 投递成功方案什么是生产端的可靠性投递？ 保障消息的成功发出 保障MQ节点的成功接收 发送端收到MQ节点(Broker) 确认应答 完善的消息补偿机制 如果想保障消息百分百投递成功，只做到前三步不一定能够保障。有些时候或者说有些极端情况，比如生产端在投递消息时可能就失败了，或者说生产端投递了消息，MQ也收到了，MQ在返回确认应答时，由于网络闪断导致生产端没有收到应答，此时这条消息就不知道投递成功了还是失败了，所以针对这些情况我们需要做一些补偿机制。","pubDate":"Wed, 29 Jan 2020 09:50:45 GMT","guid":"https://www.guaosi.com/2020/01/29/dive-into-the-advanced-features-of-rabbitmq-with-golang/","category":"消息队列,中间件,RabbitMQ"},{"title":"入门RabbitMQ之交换机详解(Golang演示)","link":"https://www.guaosi.com/2020/01/28/detailed-introduction-to-the-rabbitmq-switch-with-golang/","description":"交换机详解Exchange：交换机，接收消息，并根据路由键转发消息到绑定的队列如图为官网提供的模型，蓝色框表示Send Message，Client端把消息投递到Exchange上，通过RoutingKey路由关系将消息路由到指定的队列，绿色框代表Receive Message，Client端和队列建立监听，然后去接收消息。红色框代表RabbitMQ Server，黄色框表示RoutingKey，即Exchange和Queue需要建立绑定关系。","pubDate":"Tue, 28 Jan 2020 09:32:55 GMT","guid":"https://www.guaosi.com/2020/01/28/detailed-introduction-to-the-rabbitmq-switch-with-golang/","category":"消息队列,中间件,RabbitMQ"},{"title":"入门RabbitMQ之核心概念(Golang演示)","link":"https://www.guaosi.com/2020/01/28/core-concepts-of-rabbitmq-with-golang/","description":"简介RabbitMQ是一个开源的消息代理和队列服务器，用来通过普通协议在完全不同的应用之间共享数据，RabbitMQ是使用Erlang语言来编写的，并且RabbitMQ是基于AMQP协议的。官网：http://www.rabbitmq.com/ 哪些大厂在用，为什么？国内主要有滴滴、美团、头条、去哪儿、艺龙等互联网大厂都在使用RabblitMQ，主要原因如下： 开源、性能优秀，稳定性保障 提供可靠性消息投递模式(confirm)、返回模式(return) 与SpringAMQP完美的整合、API丰富 集群模式丰富，表达式配置，HA模式(高可用)，镜像队列模型 保证数据不丢失的前提做到高可靠性、可用性","pubDate":"Tue, 28 Jan 2020 09:31:55 GMT","guid":"https://www.guaosi.com/2020/01/28/core-concepts-of-rabbitmq-with-golang/","category":"消息队列,中间件,RabbitMQ"},{"title":"主流消息中间件介绍","link":"https://www.guaosi.com/2020/01/28/introduction-to-mainstream-messaging-middleware/","description":"ActiveMQActiveMQ是Apache出品，最流行的，能力强劲的开源消息总线，并且它是一个完全支持JMS规范的消息中间件。其丰富的API、多种集群构建模式使得他成为业界老牌消息中间件，在中小型企业中应用广泛! 当然现在可能用的相对比较少了，因为ActiveMQ性能和其他的主流MQ相比是比较一般的，早期在传统行业为王的时代它是比较流行的，现如今对于一些高并发、大数据的应用场景随处可见，在MQ的选择上如果再使用ActiveMQ往往就比较力不从心了。","pubDate":"Tue, 28 Jan 2020 09:26:27 GMT","guid":"https://www.guaosi.com/2020/01/28/introduction-to-mainstream-messaging-middleware/","category":"消息队列,MQ,中间件"},{"title":"KeepAlived原理与LVS案例","link":"https://www.guaosi.com/2020/01/25/keepalived-principle-and-LVS-case/","description":"VRRP原理基本概念VRRP（Virtual Router Redundancy Protocol，虚拟路由器冗余协议）将可以承担网关功能的一组路由器加入到备份组中，形成一台虚拟路由器，这样主机的网关设置成虚拟网关，就能够实现冗余。","pubDate":"Sat, 25 Jan 2020 14:19:58 GMT","guid":"https://www.guaosi.com/2020/01/25/keepalived-principle-and-LVS-case/","category":"Linux,服务器,高可用"},{"title":"lvs负载均衡-NAT与DR模型原理介绍","link":"https://www.guaosi.com/2020/01/22/lvs-introduction-to-the-principle-of-NAT-and-DR-model/","description":"lvs负载均衡LVS是Linux Virtual Server的缩写，从字⾯意思上翻译，LVS应该译为”Linux虚拟服务器”。通过LVS实现负载均衡集群的⽅案属于”软件⽅案”。它是作用在 第四层-传输层 上，也就是只在意 IP+端口。","pubDate":"Wed, 22 Jan 2020 08:53:12 GMT","guid":"https://www.guaosi.com/2020/01/22/lvs-introduction-to-the-principle-of-NAT-and-DR-model/","category":"Linux,服务器,高可用"},{"title":"Iptables简单介绍","link":"https://www.guaosi.com/2020/01/22/the-brief-introduction-to-iptables/","description":"基本常识防火墙防⽕墙可以⼤体分为主机防⽕墙和⽹络防⽕墙。 主机防⽕墙：针对于单个主机进⾏防护。 ⽹络防⽕墙：往往处于⽹络⼊⼝或边缘，针对于⽹络⼊⼝进⾏防护，服务于防⽕墙背后的本地局域⽹。 ⽹络防⽕墙和主机防⽕墙并不冲突，可以理解为，⽹络防⽕墙主外（集体）， 主机防⽕墙主内（个⼈）。 从物理上讲，防⽕墙可以分为硬件防⽕墙和软件防⽕墙。 硬件防⽕墙：在硬件级别实现部分防⽕墙功能，另⼀部分功能基于软件实现，性能⾼，成本⾼。 软件防⽕墙：应⽤软件处理逻辑运⾏于通⽤硬件平台之上的防⽕墙，性能低，成本低。","pubDate":"Wed, 22 Jan 2020 08:52:12 GMT","guid":"https://www.guaosi.com/2020/01/22/the-brief-introduction-to-iptables/","category":"Linux,服务器"},{"title":"Vmware和Docker的网络模式讲解","link":"https://www.guaosi.com/2020/01/22/network-of-vmware-and-docker/","description":"vmwareVMware中常用三种网络连接模式,分别是桥接模式,主机模式,NAT模式","pubDate":"Wed, 22 Jan 2020 08:51:12 GMT","guid":"https://www.guaosi.com/2020/01/22/network-of-vmware-and-docker/","category":"Linux,服务器,网络"},{"title":"压力测试简单介绍","link":"https://www.guaosi.com/2020/01/22/brief-introduction-of-pressure-test/","description":"压力测试（Stress Test），也称为强度测试、负载测试。 压力测试时模拟实际应用的软硬件环境以及用户使用过程的系统负荷，长时间或超大负荷地运行测试软件，来测试被测系统的性能、可靠性、稳定性等。 压力测试的目的以Web为例，关注项 并发量 响应速度 容错能力","pubDate":"Wed, 22 Jan 2020 08:50:12 GMT","guid":"https://www.guaosi.com/2020/01/22/brief-introduction-of-pressure-test/","category":"测试,Web"},{"title":"HTTPS原理","link":"https://www.guaosi.com/2020/01/22/simple-principle-of-https/","description":"HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。 数据安全和数据完整 对传输层数据进行加密后传输","pubDate":"Wed, 22 Jan 2020 08:49:35 GMT","guid":"https://www.guaosi.com/2020/01/22/simple-principle-of-https/","category":"Web,Linux,HTTP,服务器"},{"title":"Golang算法与数据结构：走迷宫-广度优先算法","link":"https://www.guaosi.com/2019/03/22/golang-maze-breadth-first-search/","description":"1. 介绍走迷宫是一个比较经典的算法问题，它既可以使用广度优先算法，也可以使用深度优先算法，这2种算法的本质是不一样的。 广度优先算法:周围每个点都走一下，周围的点走往后，前往下一个点继续周围的点走一下，以此类推。都是点到为止，不多走，这样可以保证达到终点时，路径一定是最短的。不需要使用到递归。 深度优先算法:从一个点，一直走到底，走到不能走。需使用递归实现。 本文使用广度优先算法实现查找迷宫最短路径。","pubDate":"Fri, 22 Mar 2019 01:51:46 GMT","guid":"https://www.guaosi.com/2019/03/22/golang-maze-breadth-first-search/","category":"Golang,算法,数据结构"},{"title":"Golang易错点:值传递和引用传递","link":"https://www.guaosi.com/2019/03/20/golang-value-passing-and-reference-passing/","description":"1. 起因我们知道golang有值传递与引用传递两种传递方式。 值类型: 基本数据类型int系列，float系列，bool，string，数组和结构体struct 引用类型: 指针，slice切片，map，管道chan，interface等 这两者的区别是，值传递相当于是复制了一份。而引用传递，是复制了相同的指针地址。如下图所示:","pubDate":"Wed, 20 Mar 2019 00:54:45 GMT","guid":"https://www.guaosi.com/2019/03/20/golang-value-passing-and-reference-passing/","category":"Golang"},{"title":"Laravel关联查询限制条数和分组查询显示为零的结果","link":"https://www.guaosi.com/2019/03/19/laravel-with-limit-and-group-show-zero/","description":"1. 需求目前有这样两个需求: 1) 查询用户，显示用户的信息以及他写过的书籍。如果用户有书籍，则显示，最多显示2本。如果没有，则不显示书籍。 2) 显示用户的id号以及对应的书籍件数(只用SQL实现，不使用业务逻辑)。","pubDate":"Tue, 19 Mar 2019 00:44:40 GMT","guid":"https://www.guaosi.com/2019/03/19/laravel-with-limit-and-group-show-zero/","category":"PHP,Laravel"},{"title":"Golang算法与数据结构：散列表(hashtable)","link":"https://www.guaosi.com/2019/03/17/golang-hash-table/","description":"1. 介绍&#160; &#160; &#160; &#160;散列表(Hash table，也叫哈希表)，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。","pubDate":"Sun, 17 Mar 2019 05:04:28 GMT","guid":"https://www.guaosi.com/2019/03/17/golang-hash-table/","category":"Golang,算法,数据结构"},{"title":"Golang算法与数据结构：栈(stack)","link":"https://www.guaosi.com/2019/03/15/golang-stack/","description":"1. 介绍有些程序员也把栈称为堆栈, 即栈和堆栈是同一个概念1) 栈的英文为(stack)2) 栈是一个先入后出(FILO-First In Last Out)的有序列表。3) 栈(stack)是限制线性表中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top)，另一端为固定的一端，称为栈底(Bottom)。4) 根据堆栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除","pubDate":"Fri, 15 Mar 2019 15:38:29 GMT","guid":"https://www.guaosi.com/2019/03/15/golang-stack/","category":"Golang,算法,数据结构"},{"title":"Golang算法与数据结构：排序(sort)","link":"https://www.guaosi.com/2019/03/15/golang-sort/","description":"1. 介绍排序是将一组数据，依指定的顺序进行排列的过程, 常见的排序:1)冒泡排序2)选择排序3)插入排序4)快速排序","pubDate":"Fri, 15 Mar 2019 06:02:31 GMT","guid":"https://www.guaosi.com/2019/03/15/golang-sort/","category":"Golang,算法,数据结构"},{"title":"Golang算法与数据结构：链表(linkedlist)","link":"https://www.guaosi.com/2019/03/14/golang-linkedlist/","description":"1. 介绍链表是有序的列表，但是它在内存中是存储如下:","pubDate":"Thu, 14 Mar 2019 00:42:44 GMT","guid":"https://www.guaosi.com/2019/03/14/golang-linkedlist/","category":"Golang,算法,数据结构"},{"title":"Laravel的限制条数再分页","link":"https://www.guaosi.com/2019/03/13/laravel-limit-paginate/","description":"1. 需求&#160; &#160; &#160; &#160; 有这么一个需求，我想取出一个表(比如user表)中，按照某一排序规则(比如按照时间倒叙)，取出前100条，进行分页，每页10条。应该如何实现？自然而然可能会这样写下: 1$users = User::orderBy('id','desc')-&gt;limit(100)-&gt;paginate(10) 最后打印结果可以发现，limit并未生效，依旧是将所有结果进行分页。","pubDate":"Wed, 13 Mar 2019 05:00:27 GMT","guid":"https://www.guaosi.com/2019/03/13/laravel-limit-paginate/","category":"PHP,Laravel"},{"title":"Golang算法与数据结构：队列(queue)","link":"https://www.guaosi.com/2019/03/12/golang-queue/","description":"1. 基本介绍 队列是一个有序列表，可以用数组或是链表来实现。 遵循先入先出的原则。即:先存入队列的数据，要先取出。后存入的要后取出","pubDate":"Tue, 12 Mar 2019 08:46:28 GMT","guid":"https://www.guaosi.com/2019/03/12/golang-queue/","category":"Golang,算法,数据结构"},{"title":"记一次Golang网络编程开发聊天室有感","link":"https://www.guaosi.com/2019/03/11/golang-tcp-socket/","description":"1. 起因&#160; &#160; &#160; &#160;一直都是使用PHP的B/S开发(不知道swoole的socket算不算)，很想尝试一下C/S开发是什么感觉。于是乎，就做了一个聊天室，这是一个网络编程几乎必做的项目。","pubDate":"Mon, 11 Mar 2019 06:47:08 GMT","guid":"https://www.guaosi.com/2019/03/11/golang-tcp-socket/","category":"Golang,tcp,网络编程"},{"title":"Golang算法与数据结构：稀疏数组(sparsearray)","link":"https://www.guaosi.com/2019/03/11/golang-sparsearray/","description":"1. 基本介绍&#160; &#160; &#160; &#160;当一个数组中大部分元素为0，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。 2. 处理方法1) 记录数组一共有几行几列，有多少个不同的值2) 思想:把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模","pubDate":"Mon, 11 Mar 2019 05:45:11 GMT","guid":"https://www.guaosi.com/2019/03/11/golang-sparsearray/","category":"Golang,算法,数据结构"},{"title":"手摸手教你破解移动光猫吉比特--H2-3","link":"https://www.guaosi.com/2019/03/09/crack-china-mobile-optical-modem-h2-3/","description":"1. 起因&#160; &#160; &#160; &#160;过年期间家里装了2年免费的移动光纤(真香)，可是移动装机默认光猫都是路由模式，装机师傅以及移动人工客服都是拒绝给超级账户的。所以只能自己想办法解决。 2. 解决办法1.工信部投诉，百试百灵2.淘宝或者闲鱼花钱让别人破解(我查了貌似没有这个型号)3.手摸手自己折腾自己搞","pubDate":"Sat, 09 Mar 2019 10:20:33 GMT","guid":"https://www.guaosi.com/2019/03/09/crack-china-mobile-optical-modem-h2-3/","category":"crack"},{"title":"手摸手教你让Laravel开发Api更得心应手","link":"https://www.guaosi.com/2019/02/26/laravel-api-initialization-preparation/","description":"1. 起因&#160; &#160; &#160; &#160;随着前后端完全分离，PHP也基本告别了view模板嵌套开发，转而专门写资源接口。Laravel是PHP框架中最优雅的框架，国内也越来越多人告别ThinkPHP选择了Laravel。Laravel框架本身对API有支持，但是感觉再工作中还是需要再做一些处理。Lumen用起来不顺手，有些包不能很好地支持。所以，将Laravel框架进行一些配置处理，让其在开发API时更得心应手。 内容划水过长，请谨慎打开","pubDate":"Tue, 26 Feb 2019 02:47:04 GMT","guid":"https://www.guaosi.com/2019/02/26/laravel-api-initialization-preparation/","category":"PHP,Laravel,Api"}]}
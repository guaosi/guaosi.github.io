{"title":"guaosi的博客","description":"后端,PHP,Linux,golang,python,开发者,程序猿,程序媛,极客,编程,代码,开源,IT网站,docker","language":"","link":"//www.guaosi.com","pubDate":"Fri, 14 Dec 2018 06:58:15 GMT","lastBuildDate":"Tue, 18 Dec 2018 01:35:49 GMT","generator":"hexo-generator-json-feed","webMaster":"guaosi","items":[{"title":"二维数组的巧妙整合","link":"//www.guaosi.com/2018/12/14/complex-two-dimensional-arrays/","description":"起因在工作中，经常会遇到多个多维数组或者orm对象数组需要整合的情况。通过整合好数据，然后输出给前端。 数据比如现在，有2个orm对象，他们的表间关系存在不明显，互相没有做模型关联，但是id相同。 $name_data对象数组(已转json格式，方便查看) 12345678910111213141516171819202122[ &#123; \"id\": 1, \"name\": \"std_name_0\" &#125;, &#123; \"id\": 2, \"name\": \"std_name_1\" &#125;, &#123; \"id\": 3, \"name\": \"std_name_2\" &#125;, &#123; \"id\": 4, \"name\": \"std_name_3\" &#125;, &#123; \"id\": 5, \"name\": \"std_name_4\" &#125;] $order_data对象数组(已转json格式，方便查看) 123456789101112131415161718192021222324252627282930[ &#123; \"id\": 2, \"order_count\": 0 &#125;, &#123; \"id\": 3, \"order_count\": 2 &#125;, &#123; \"id\": 4, \"order_count\": 4 &#125;, &#123; \"id\": 5, \"order_count\": 6 &#125;, &#123; \"id\": 6, \"order_count\": 8 &#125;, &#123; \"id\": 7, \"order_count\": 10 &#125;, &#123; \"id\": 8, \"order_count\": 12 &#125;] 现在我想把这2个orm对象数组整合成一个数组，方便\b前端调用，想\b转成的数据结构如下所示（已转json格式，方便查看）123456789101112131415161718192021222324252627282930313233343536373839404142&#123; \"1\": &#123; \"id\": 1, \"name\": \"std_name_0\", \"order_count\": 0 &#125;, \"2\": &#123; \"id\": 2, \"name\": \"std_name_1\", \"order_count\": 0 &#125;, \"3\": &#123; \"id\": 3, \"name\": \"std_name_2\", \"order_count\": 2 &#125;, \"4\": &#123; \"id\": 4, \"name\": \"std_name_3\", \"order_count\": 4 &#125;, \"5\": &#123; \"id\": 5, \"name\": \"std_name_4\", \"order_count\": 6 &#125;, \"6\": &#123; \"id\": 6, \"order_count\": 8, \"name\": \"\" &#125;, \"7\": &#123; \"id\": 7, \"order_count\": 10, \"name\": \"\" &#125;, \"8\": &#123; \"id\": 8, \"order_count\": 12, \"name\": \"\" &#125;&#125; 实现想法一\b\b脑子里一闪间的想法，2个数组\b整合成一个，并且根据id来区别。容易，做2个foreach循环就行\b了，判断\bid相同的\b，放到\b\b一个数组里\b就行了，\b于是可能会想到了下面的代码1234567891011foreach ($name_data as $val)&#123; foreach ($order_data as $v)&#123; if($v-&gt;id == $val-&gt;id)&#123; $data['id'] = $v-&gt;id; $data['name'] = $val-&gt;name; $data['order_count'] = $v-&gt;order_count; $users_info[]=$data; break; &#125; &#125;&#125; 运行后的结果(已转json格式，方便查看)12345678910111213141516171819202122[ &#123; \"id\": 2, \"name\": \"std_name_1\", \"order_count\": 0 &#125;, &#123; \"id\": 3, \"name\": \"std_name_2\", \"order_count\": 2 &#125;, &#123; \"id\": 4, \"name\": \"std_name_3\", \"order_count\": 4 &#125;, &#123; \"id\": 5, \"name\": \"std_name_4\", \"order_count\": 6 &#125;] 很明显，这不是我们想要的结果。 想法二\b想法一的想法太武断，只考虑了2个ID相等的\b情况，没有考虑到不同，所以导致只做了一半的事情，答案不正确。再次经过考虑后，\b可能有了如下的代码12345678910111213141516171819foreach ($name_data as $val)&#123; $flag = false; foreach ($order_data as $v)&#123; if($v-&gt;id == $val-&gt;id)&#123; $users_info[$v-&gt;id]['id'] = $v-&gt;id; $users_info[$v-&gt;id]['name'] = $val-&gt;name; $users_info[$v-&gt;id]['order_count'] = $v-&gt;order_count; $flag = true; break; &#125;else&#123; $users_info[$v-&gt;id]['id'] = $v-&gt;id; $users_info[$v-&gt;id]['order_count'] = $v-&gt;order_count; &#125; &#125; if(!$flag)&#123; $users_info[$val-&gt;id]['id'] = $val-&gt;id; $users_info[$val-&gt;id]['name'] = $val-&gt;name; &#125;&#125; \b\b运行过后的结果(已转json格式，方便查看)1234567891011121314151617181920212223242526272829303132333435363738&#123; \"1\": &#123; \"id\": 1, \"name\": \"std_name_0\" &#125;, \"2\": &#123; \"id\": 2, \"order_count\": 0, \"name\": \"std_name_1\" &#125;, \"3\": &#123; \"id\": 3, \"order_count\": 2, \"name\": \"std_name_2\" &#125;, \"4\": &#123; \"id\": 4, \"order_count\": 4, \"name\": \"std_name_3\" &#125;, \"5\": &#123; \"id\": 5, \"order_count\": 6, \"name\": \"std_name_4\" &#125;, \"6\": &#123; \"id\": 6, \"order_count\": 8 &#125;, \"7\": &#123; \"id\": 7, \"order_count\": 10 &#125;, \"8\": &#123; \"id\": 8, \"order_count\": 12 &#125;&#125; 这次，跟我们想要的结果很接近了。其实，这样已经可以传给我们的前端，让前端自己去判断处理了。 想法三那有没有一种简单点的办法，既可以实现我们要的数据结果，又简单方便好理解\b呢？答案是有的，其实想法二已经体现出来了，就是\b活用php的数组特性，充分利用id来判断相同可以整合的数据，于是想法三就诞生了。 12345678910foreach ($name_data as $val)&#123; $users_info[$val-&gt;id]['id'] = $val-&gt;id; $users_info[$val-&gt;id]['name'] = $val-&gt;name; $users_info[$val-&gt;id]['order_count'] = 0;&#125;foreach ($order_data as $val)&#123; $users_info[$val-&gt;id]['id'] = $val-&gt;id; $users_info[$val-&gt;id]['order_count'] = $val-&gt;order_count; $users_info[$val-&gt;id]['name'] = $users_info[$val-&gt;id]['name']??'';&#125; \b\b运行过后的结果(已转json格式，方便查看) 123456789101112131415161718192021222324252627282930313233343536373839404142&#123; \"1\": &#123; \"id\": 1, \"name\": \"std_name_0\", \"order_count\": 0 &#125;, \"2\": &#123; \"id\": 2, \"name\": \"std_name_1\", \"order_count\": 0 &#125;, \"3\": &#123; \"id\": 3, \"name\": \"std_name_2\", \"order_count\": 2 &#125;, \"4\": &#123; \"id\": 4, \"name\": \"std_name_3\", \"order_count\": 4 &#125;, \"5\": &#123; \"id\": 5, \"name\": \"std_name_4\", \"order_count\": 6 &#125;, \"6\": &#123; \"id\": 6, \"order_count\": 8, \"name\": \"\" &#125;, \"7\": &#123; \"id\": 7, \"order_count\": 10, \"name\": \"\" &#125;, \"8\": &#123; \"id\": 8, \"order_count\": 12, \"name\": \"\" &#125;&#125; \b总结\b以上三种想法可以看出来，想法三具有以下三个特点: \b简单高效，想法一与想法二\b最大运行次数都是m*n次，然而想法三是m+n次，速度效率存在本质的区别。 可以实现我们想要的数据结构，并且相比想法二，减少了大量的逻辑代码。 \b活用php数组特性，利用id来区分以及整合数组，在我们的平时工作中，很经常会遇到类似相关的问题。 虽然这里只是以两个对象数组为例，其实还可以更多应用到\b其他多维数组，多个数组整合之类的，\b灵活变通，类似问题都会迎刃而解。 \b案例完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?php//制作名字与ID的对象数组function mockNameData($n)&#123; $name_data = []; for ($i = 0; $i &lt; $n; $i++) &#123; $obj = new \\stdClass(); $obj-&gt;id = $i + 1; $obj-&gt;name = 'std_name_' . $i; $name_data[] = $obj; &#125; return $name_data;&#125;//制作订单数量与ID的对象数组function mockOrderData($n)&#123; $order_data = []; for ($i = 0; $i &lt; $n; $i++) &#123; $obj = new \\stdClass(); $obj-&gt;id = $i + 2; $obj-&gt;order_count = $i * 2; $order_data[] = $obj; &#125; return $order_data;&#125;// 想法一function think1($name_data, $order_data)&#123; $users_info = []; foreach ($name_data as $val) &#123; foreach ($order_data as $v) &#123; if ($v-&gt;id == $val-&gt;id) &#123; $data['id'] = $v-&gt;id; $data['name'] = $val-&gt;name; $data['order_count'] = $v-&gt;order_count; $users_info[] = $data; break; &#125; &#125; &#125; return $users_info;&#125;//想法二function think2($name_data, $order_data)&#123; $users_info = []; foreach ($name_data as $val) &#123; $flag = false; foreach ($order_data as $v) &#123; if ($v-&gt;id == $val-&gt;id) &#123; $users_info[$v-&gt;id]['id'] = $v-&gt;id; $users_info[$v-&gt;id]['name'] = $val-&gt;name; $users_info[$v-&gt;id]['order_count'] = $v-&gt;order_count; $flag = true; break; &#125; else &#123; $users_info[$v-&gt;id]['id'] = $v-&gt;id; $users_info[$v-&gt;id]['order_count'] = $v-&gt;order_count; &#125; &#125; if (!$flag) &#123; $users_info[$val-&gt;id]['id'] = $val-&gt;id; $users_info[$val-&gt;id]['name'] = $val-&gt;name; &#125; &#125; return $users_info;&#125;//想法三function think3($name_data, $order_data)&#123; $users_info = []; foreach ($name_data as $val) &#123; $users_info[$val-&gt;id]['id'] = $val-&gt;id; $users_info[$val-&gt;id]['name'] = $val-&gt;name; $users_info[$val-&gt;id]['order_count'] = 0; &#125; foreach ($order_data as $val) &#123; $users_info[$val-&gt;id]['id'] = $val-&gt;id; $users_info[$val-&gt;id]['order_count'] = $val-&gt;order_count; $users_info[$val-&gt;id]['name'] = $users_info[$val-&gt;id]['name'] ?? ''; &#125; return $users_info;&#125;//设置虚拟数据的长度$n = 5;//设置虚拟数据的长度$m = 7;//制作名字与ID的对象数组$name_data = mockNameData($n);////制作订单数量与ID的对象数组$order_data = mockOrderData($m);//打印想法1print_r(think1($name_data, $order_data));//打印想法2print_r(think2($name_data, $order_data));//打印想法3print_r(think3($name_data, $order_data));","pubDate":"Fri, 14 Dec 2018 06:58:15 GMT","guid":"//www.guaosi.com/2018/12/14/complex-two-dimensional-arrays/","category":"php"},{"title":"git pull或git checkout 后保持权限不变","link":"//www.guaosi.com/2018/12/06/git-auto-change/","description":"1. 起因服务器上的项目,一般都是使用用户组www-data或者www来保证权限安全,不会使用root的。但是git pull下来的新文件或者修改的文件,则会把原有的文件的权限更改为644,用户组改为root。","pubDate":"Thu, 06 Dec 2018 08:43:14 GMT","guid":"//www.guaosi.com/2018/12/06/git-auto-change/","category":"git"},{"title":"docker常用基础","link":"//www.guaosi.com/2018/11/30/docker-basic/","description":"1. docker用来干什么将做好的环境和代码，打包成镜像，可以让各个地方都可以直接使用，不再受到环境的限制。 2. docker与虚拟机的区别1.虚拟机是模拟整个操作系统，包括硬件部分2.docker是使用linux容器，通过进程隔离，拥有自己的文件系统，不会跟宿主机产生错乱。3.docker没有自己的内核，使用的是宿主机的内核。","pubDate":"Fri, 30 Nov 2018 03:39:18 GMT","guid":"//www.guaosi.com/2018/11/30/docker-basic/","category":"docker"}]}